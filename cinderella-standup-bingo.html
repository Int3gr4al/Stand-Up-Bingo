<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Cinderella's Stand-Up Bingo ‚Äî Weekly Multiplayer</title>
<style>
  body { margin:0; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial; background:#0b0b0f; color:#eaeaf0; }
  .wrap { max-width: 1100px; margin: 0 auto; padding: 24px 16px 64px; }
  h1 { margin:0 0 6px 0; font-size: clamp(22px,3vw,36px); }
  .muted { color:#a3a3ad; }
  .controls { display:flex; gap:8px; flex-wrap:wrap; align-items:center; margin: 12px 0 16px; }
  input, button { background:#17171d; color:#eaeaf0; border:1px solid #2a2a34; border-radius:12px; padding:10px 12px; }
  button { cursor:pointer; }
  button:hover { background:#1e1e26; }
  .grid { display:grid; gap:10px; grid-template-columns: repeat(5, minmax(120px,1fr)); }
  .tile { display:flex; flex-direction:column; justify-content:space-between; align-items:center;
          min-height:110px; padding:10px; text-align:center; border:1px solid #2a2a34; border-radius:14px; background:#14141a; }
  .tile.on { background: rgba(74, 222, 128, .16); border-color: rgba(74,222,128,.7); color:#c9f6d9; }
  .who { display:flex; flex-wrap:wrap; gap:4px; justify-content:center; padding-bottom:4px; }
  .badge { font-size:11px; padding:2px 8px; border-radius:999px; border:1px solid #ffffff40;
           max-width: 140px; white-space:nowrap; overflow:hidden; text-overflow:ellipsis; }
  .panel { background:#101018; border:1px solid #2a2a34; border-radius:16px; padding:12px; }
  .presence li { display:flex; justify-content:space-between; align-items:center; gap:8px; padding:6px 0; border-bottom:1px dashed #2a2a34; }
  .presence li:last-child { border-bottom:0; }
  .presence .actions button { padding:6px 8px; border-radius:10px; }
  .right { display:grid; gap:10px; }
  .confetti { position:fixed; inset:0; pointer-events:none; overflow:hidden; }
  @keyframes fall { to { transform: translateY(110vh) rotate(720deg); opacity:.9; } }
</style>
</head>
<body>
<div class="confetti" id="confetti"></div>
<div class="wrap">
  <header>
    <h1>üéôÔ∏è Cinderella‚Äôs Stand-Up Bingo</h1>
    <div class="muted">Shared board, live clicks, weekly history (Mon‚ÄìFri).</div>
    <div class="controls">
      <input id="name" placeholder="Display name" />
      <button id="join">Join</button>
      <button id="reset">Reset marks</button>
      <button id="shuffle" title="Reorder tiles for future weeks only">Shuffle next week</button>
      <button id="adminBtn" title="Admin login / logout">Admin</button>
      <span id="adminState" class="muted" style="margin-left:6px;"></span>
      <span id="weeklabel" class="muted" style="margin-left:auto;"></span>
    </div>
  </header>

  <main style="display:grid; grid-template-columns: 1fr 300px; gap:16px; align-items:start;">
    <section>
      <div id="grid" class="grid"></div>
      <div class="muted" style="margin-top:8px;">Lines and blackout detected per user; names show who marked each tile.</div>
    </section>

    <aside class="right">
      <div class="panel">
        <div style="display:flex;justify-content:space-between;align-items:center;">
          <strong>Presence</strong>
          <small id="me"></small>
        </div>
        <ul id="presence" class="presence" style="list-style:none; padding:0; margin:10px 0 0;"></ul>
      </div>
      <div class="panel">
        <strong>History</strong>
        <div id="history" class="muted" style="margin-top:8px; font-size:14px;">‚Äî</div>
      </div>
    </aside>
  </main>
</div>

<script type="module">
import { createClient } from "https://esm.sh/@supabase/supabase-js@2";

/* === YOUR SUPABASE PROJECT === */
const SUPABASE_URL = "https://xkqejhirtnlxuzyzbfju.supabase.co";
const SUPABASE_ANON_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InhrcWVqaGlydG5seHV6eXpiZmp1Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjE5OTQxODUsImV4cCI6MjA3NzU3MDE4NX0.a0O8w_Mxi3YQwuBorpyITIT7HxAqlcNaSCbKhHTiOVU";
const supabase = createClient(SUPABASE_URL, SUPABASE_ANON_KEY);

/* === CONFIG === */
const BOARD_TITLE = "Cinderella‚Äôs Stand-Up Bingo";
const TILES = [
  "Bits and bobs","BAU","Technical Issues","I've got a Dr's appointment","Headache",
  "Eyes hurting","Not feeling great today","Lots of emails to go through","Meetings","Pen Test",
  "Not sure who's been","Teams having issues","Talking over / coughing over people","On mute","Laptop doing updates"
];

/* === DOM === */
const gridEl = document.getElementById("grid");
const joinBtn = document.getElementById("join");
const resetBtn = document.getElementById("reset");
const shuffleBtn = document.getElementById("shuffle");
const adminBtn = document.getElementById("adminBtn");
const adminState = document.getElementById("adminState");
const nameEl = document.getElementById("name");
const presenceEl = document.getElementById("presence");
const meEl = document.getElementById("me");
const weekLabel = document.getElementById("weeklabel");
const historyEl = document.getElementById("history");
const confettiHost = document.getElementById("confetti");

/* === LOCAL USER === */
const localId = getOrSet("bingo_user_id", crypto.randomUUID());
let displayName = getOrSet("bingo_display_name", "");
nameEl.value = displayName;
meEl.textContent = `You: ${displayName || localId.slice(0,8)}`;

/* === STATE === */
let boardId = null;
let weekId = null;
let tiles = [];
let myMarks = new Set();           // computed from selections
let selectionsByTile = {};         // tile_index -> Set<user_id>
let completedLines = new Set();    // for ‚Äúnew line only‚Äù confetti
let prevBlackout = false;
let usersById = {};                // user_id -> {display_name, last_seen}
let adminToken = null;             // set after login

/* === Helpers === */
function getMonday(d=new Date()) {
  const n = new Date(Date.UTC(d.getUTCFullYear(), d.getUTCMonth(), d.getUTCDate()));
  const day = n.getUTCDay() || 7; n.setUTCDate(n.getUTCDate() - day + 1); return n;
}
function fmtDate(date) { return date.toISOString().slice(0,10); }
function isWeekday(d=new Date()) { const wd = d.getDay(); return wd >= 1 && wd <= 5; }
function getOrSet(key, val) { const v = localStorage.getItem(key); if (v) return v; localStorage.setItem(key, val); return val; }
function colorFor(id) { const h = [...id].reduce((a,c)=>a+c.charCodeAt(0),0)%360; return `hsl(${h},70%,55%)`; }
function burstConfetti(N=90) {
  for (let i=0;i<N;i++) {
    const d=document.createElement('div');
    d.style.position='absolute';d.style.width='8px';d.style.height='8px';
    d.style.left=Math.random()*100+'%'; d.style.top='-12px';
    d.style.background=`hsl(${Math.floor(Math.random()*360)},90%,60%)`;
    d.style.animation=`fall ${1.6 + Math.random()*1.6}s linear forwards`;
    confettiHost.appendChild(d);
    setTimeout(()=>d.remove(), 3300);
  }
}

/* === Bootstrap === */
await ensureUser();
await ensureBoard();
await ensureWeek();
await subscribeRealtime();
await loadSelections();
await loadHistory();
render();

/* === UI actions === */
joinBtn.onclick = async () => {
  displayName = nameEl.value.trim() || `Player-${localId.slice(0,4)}`;
  localStorage.setItem("bingo_display_name", displayName);
  meEl.textContent = `You: ${displayName}`;
  await ensureUser(true);
  renderPresence(); // optimistic refresh
};

resetBtn.onclick = async () => {
  const { error } = await supabase
    .from("selections")
    .delete()
    .eq("week_id", weekId)
    .eq("user_id", localId);
  if (error) console.error(error);
};

shuffleBtn.onclick = async () => {
  const nextMon = getMonday(new Date(Date.now() + 8.64e7*7));
  const shuffled = [...tiles].sort(()=>Math.random()-0.5);
  const { error: e1 } = await supabase
    .from("weeks")
    .upsert({ board_id: boardId, week_start: fmtDate(nextMon) })
    .select("id").single();
  if (e1) console.error(e1);
  const { error: e2 } = await supabase.from("boards").update({ tiles: shuffled }).eq("id", boardId);
  if (e2) console.error(e2);
  alert("Shuffled board saved for next week.");
};

adminBtn.onclick = async () => {
  if (adminToken) {
    adminToken = null;
    adminState.textContent = "(admin: logged out)";
    renderPresence();
    return;
  }
  const token = prompt("Enter admin token");
  if (!token) return;

  const { data, error } = await supabase.rpc("admin_check_token", { p_token: token });
  if (error) return alert("Token check failed: " + (error.message || error));
  if (data === true) {
    adminToken = token;
    adminState.textContent = "(admin: logged in)";
    renderPresence();
  } else {
    alert("Invalid admin token");
  }
};


/* === Data bootstrap === */
async function ensureUser(update=false){
  const now = new Date().toISOString();
  const payload = { id: localId, display_name: displayName || `Player-${localId.slice(0,4)}`, last_seen: now };
  if (update) {
    await supabase.from("users").upsert(payload);
  } else {
    const { data } = await supabase.from("users").select("id").eq("id", localId);
    if (!data || !data.length) await supabase.from("users").insert(payload);
    else await supabase.from("users").update({ last_seen: now, display_name: payload.display_name }).eq("id", localId);
  }
}

async function ensureBoard(){
  let { data, error } = await supabase.from("boards").select("id, tiles").eq("title", BOARD_TITLE).maybeSingle();
  if (error) console.error(error);
  if (!data) {
    const { data: ins, error: e2 } = await supabase.from("boards").insert({ title: BOARD_TITLE, tiles: TILES }).select("id, tiles").single();
    if (e2) console.error(e2);
    boardId = ins.id; tiles = ins.tiles;
  } else { boardId = data.id; tiles = data.tiles; }
}

async function ensureWeek(){
  const mon = fmtDate(getMonday());
  let { data, error } = await supabase
    .from("weeks")
    .select("id, week_start")
    .eq("board_id", boardId)
    .eq("week_start", mon)
    .maybeSingle();
  if (error) console.error(error);
  if (!data) {
    const { data: ins, error: e2 } = await supabase
      .from("weeks").insert({ board_id: boardId, week_start: mon }).select("id, week_start").single();
    if (e2) console.error(e2);
    weekId = ins.id;
  } else weekId = data.id;

  weekLabel.textContent = `Week starting ${mon} (Mon‚ÄìFri${isWeekday()?'':' ‚Äî viewing only'})`;
}

async function loadSelections(){
  myMarks = new Set();
  selectionsByTile = {};
  for (let i=0;i<tiles.length;i++) selectionsByTile[i] = new Set();
  const { data, error } = await supabase
    .from("selections")
    .select("tile_index, user_id, marked")
    .eq("week_id", weekId);
  if (error) console.error(error);
  (data||[]).forEach(r=>{
    if (r.marked) {
      selectionsByTile[r.tile_index].add(r.user_id);
      if (r.user_id === localId) myMarks.add(r.tile_index);
    }
  });
  render();
}

async function loadHistory(){
  const { data, error } = await supabase
    .from("weeks")
    .select("id, week_start")
    .eq("board_id", boardId)
    .order("week_start", { ascending: false })
    .limit(10);
  if (error) { console.error(error); return; }
  historyEl.innerHTML = data.map(w => {
    return `<div><a href="#" data-week="${w.id}" class="hist">Week ${w.week_start}</a></div>`;
  }).join("");
  [...document.querySelectorAll(".hist")].forEach(a=>{
    a.onclick = async (e)=>{
      e.preventDefault();
      weekId = a.getAttribute("data-week");
      await loadSelections();
      weekLabel.textContent = `Week starting ${a.textContent.replace('Week ','')} (history)`;
    };
  });
}

async function subscribeRealtime(){
  supabase.channel("selections")
    .on("postgres_changes", { event: "*", schema: "public", table: "selections", filter: `week_id=eq.${weekId}` }, payload => {
      const r = payload.new || payload.old;
      if (!r) return;
      const set = selectionsByTile[r.tile_index] || new Set();
      if (payload.eventType === "DELETE" || (payload.new && payload.new.marked === false)) {
        set.delete(r.user_id);
        if (r.user_id === localId) myMarks.delete(r.tile_index);
      } else {
        set.add(r.user_id);
        if (r.user_id === localId) myMarks.add(r.tile_index);
      }
      selectionsByTile[r.tile_index] = set;
      confettiIfNewLineOrBlackout();
      render();
    })
    .subscribe();

  setInterval(async ()=>{
    await supabase.from("users").update({ last_seen: new Date().toISOString() }).eq("id", localId);
    renderPresence();
  }, 15000);
  renderPresence();
}

/* Presence now fills usersById so tiles can show **names** and admin can delete */
function renderPresence(){
  const since = new Date(Date.now()-30000).toISOString();
  supabase.from("users").select("id, display_name, last_seen").then(({data})=>{
    const rows = (data||[]).sort((a,b)=> (b.last_seen||'').localeCompare(a.last_seen||''));
    usersById = Object.fromEntries(rows.map(u => [u.id, u]));
    presenceEl.innerHTML = rows.map(u=>{
      const online = (u.last_seen||'') > since;
      const actions = (adminToken && u.id !== localId)
        ? `<span class="actions"><button title="Remove user" onclick="window.__removeUser('${u.id}','${encodeURIComponent(u.display_name)}')">üóë</button></span>`
        : "";
      return `<li><span>${u.display_name}</span><span style="color:${online?'#4ade80':'#a3a3ad'}">${online?'Online':'Away'}</span>${actions}</li>`;
    }).join("") || "<div class='muted'>No one yet. Click Join.</div>";

    adminState.textContent = adminToken ? "(admin: logged in)" : "(admin: logged out)";
  });
}

/* Expose a tiny helper for the inline onclick above */
window.__removeUser = async (uid, encName) => {
  if (!adminToken) return alert("Admin not logged in");
  const name = decodeURIComponent(encName);
  if (!confirm(`Really remove user ‚Äú${name}‚Äù? This also deletes their marks.`)) return;
  const { error } = await supabase.rpc("admin_remove_user", { p_token: adminToken, p_user: uid });
  if (error) { alert("Delete failed: " + (error.message || error)); return; }
  // Refresh lists
  await loadSelections();
  renderPresence();
  render();
};

function render(){
  gridEl.innerHTML = "";
  tiles.forEach((t, i) => {
    const on = myMarks.has(i);
    const who = [...(selectionsByTile[i]||[])];
    const el = document.createElement("button");
    el.className = "tile" + (on ? " on" : "");
    el.innerHTML = `
      <div style="flex:1;display:grid;place-items:center;"><div>${t}</div></div>
      <div class="who">
        ${who.map(uid=>{
          const name = (usersById[uid]?.display_name) || uid;
          const col = colorFor(uid);
          return `<span class="badge" style="border-color:${col}80;color:${col};background:${col}20" title="${name}">${name}</span>`;
        }).join("")}
      </div>`;
    el.onclick = async () => {
      if (!isWeekday()) return alert("Clicks only allowed Mon‚ÄìFri for the active week.");
      await supabase.rpc("toggle_selection", { _week: weekId, _user: localId, _tile: i });
      // realtime will update UI
    };
    gridEl.appendChild(el);
  });
}

/* Confetti only when a NEW line completes (or first blackout) */
function confettiIfNewLineOrBlackout() {
  const lines = [
    [0,1,2,3,4],[5,6,7,8,9],[10,11,12,13,14],
    [0,5,10,15,20],[1,6,11,16,21],[2,7,12,17,22],[3,8,13,18,23],[4,9,14,19,24],
    [0,6,12,18,24],[4,8,12,16,20]
  ].filter(line => line.every(i => i < tiles.length));
  const isLine = (line)=> line.every(i => myMarks.has(i));
  const current = lines.map((_,idx)=> ({idx, ok:isLine(lines[idx])})).filter(x=>x.ok).map(x=>x.idx);
  const newOnes = current.filter(idx => !completedLines.has(idx));
  current.forEach(idx => completedLines.add(idx));
  if (newOnes.length > 0) burstConfetti(80);

  const blackout = myMarks.size === tiles.length && tiles.length > 0;
  if (blackout && !prevBlackout) burstConfetti(140);
  prevBlackout = blackout;
}
</script>
</body>
</html>
